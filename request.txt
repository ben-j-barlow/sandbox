I have created My Express App and My Core App. I would suggest running each app to build context around the problem I am trying to solve. When running My Core App, it only works if you have an equal number of sliders and plots. You must click 'Add slider' on load up for it to work. My express app is how I would like my app to appear (with sliders controlling the plot sitting right beside the plot).

In both apps, I am using exactly one slider to affect the data in exactly one plot. In My Express App, not only does the data respond to exactly one slider, but the entire plot reacts to exactly one slider.  

But, in My Core App, all the plots are reacting to a single slider change (evidenced by the time in the title changing for all plots when one slider is changed). This inefficiency isn't problematic for this toy example, but my final app will use the sliders to insert parameters into a SQL query, make a call to a database, and then render the data. Hence, it is very important that I learn to make only one plot to react to a slider input.

My questions are listed below, with the item of highest importance at the top.

Question 1: Rather than having one slider beside each plot, I would like a mixture of sliders and text boxes. The mixture will be decided by user input. For example, if my user enters into my app's text box the following SQL query

"""
Select *
From Tbl
Where x = {slider_input, min=0, max=10, step=1, label="Enter value for x"}
And y = {text_input, label="Enter value for y"}
"""

then I would like to generate a slider and a text box next to each plot. I am very confident this is possible as there are multiple insert and update functions for the UI. But, I would like to know the recommended approach for this. 

Question 2: Can you advise how I can program the desired behaviour (each plot reacting to exactly one set of user inputs) in My Core App (taking inspiration from My Express App)?

Question 3: Before I continue programming my app, I should verify that Shiny for Python is a reasonable tool for my problem. Is my vision of making a call to the database upon a slider value changing a realistic expectation? I would like this to occur asynchronously, without blocking changes to other sliders. If another slider is changed, the query should also run in parallel, rather than joining a queue. I have found the docs for non-blocking operations (https://shiny.posit.co/py/docs/nonblocking.html) but haven't been successful with my aim (yet).

Question 4: I would like to have 2 buttons on each plot area (a plot area is a plot and its corresponding user inputs) called 'Duplicate' and 'Remove'. Hitting duplicate will copy the properties of the plot area (the slider value, and therefore, the data) and create a new plot area immediately below. Changing the slider value in the new plot area will update only its corresponding plot (not the data in the plot area that was just duplicated). Clicking Remove will of course remove the given plot area. Is this possible?


######## My Express App ################

from shiny import reactive
from shiny.express import ui, module
from shinywidgets import render_plotly
import numpy as np
import pandas as pd
from datetime import datetime


@reactive.calc
def df():
    x = np.r_[1 : (2 + 1)]
    y = np.r_[1 : (2 + 1)]
    return pd.DataFrame({"x": x, "y": y})

@module
def plot_area(input, output, session):
    mult = reactive.value(1)
    
    with ui.layout_columns(col_widths=[8, 4]):
        with ui.card(full_screen=True):

            @render_plotly
            def hist():
                import plotly.express as px

                df_ = df()
                p = px.line(x=df_["x"], y=df_["y"] * mult.get(), title=f"time is {str(datetime.now())}")
                p.layout.update(showlegend=False)
                return p

        with ui.card(full_screen=False):
            ui.input_slider(
                id=f"slider", min=1, max=2, value=1, step=1, label=f"Control XX"
            )

    @reactive.effect
    def increment():
        mult.set(input.slider.get())
 
plot_area("one")
ui.hr()
plot_area("two")



######### My Core App ################
import matplotlib.pyplot as plt
import numpy as np
from shiny import ui, render, App, module, reactive
from datetime import datetime

MAX_PLOTS = 5


# UI module for a single plot
@module.ui
def plot_ui():
    # Returns a placeholder for a plot that will be rendered server-side
    return ui.output_plot("plot")

# Server module to generate and render each plot
@module.server
def plot_server(
    input, output, session, plot_id: int, mult: int, max_plots: int = MAX_PLOTS
):
    @render.plot
    def plot():
        # Generate data for the plot based on the plot_id
        x = np.r_[1 : (plot_id + 1)]
        y = np.r_[1 : (plot_id + 1)] * mult

        fig, ax = plt.subplots()
        ax.scatter(x, y)
        ax.set_xlim(0, max_plots)
        ax.set_ylim(0, max_plots)
        ax.set_title(f"1: {plot_id}. mult is {mult}. n is {max_plots}. time is {str(datetime.now())}")
        return fig


app_ui = ui.page_fluid(
    ui.panel_title("Dynamic number of plots"),
    ui.layout_sidebar(
        ui.sidebar(
            ui.input_action_button("add_plot_button", "Add plot"),
            ui.output_text_verbatim("current_plot_count_display"),
            ui.input_slider(
                "global_slider", label="Slider", value=3, min=1, max=5, step=1
            ),
            width=250,  # Optional: give sidebar a consistent width
        ),
        # Main panel to display all plots
        ui.input_action_button("add_slider_button", "Add Slider"),
        ui.output_text(id="txt_out"),
        ui.output_ui("plots"),
    ),
)


def server(input, output, session):
    current_n_plots = reactive.Value(1)  # Start with 1 plot
    current_n_slider = reactive.Value(0)

    @render.text
    def txt_out():
        return f"Number of sliders is {str(current_n_slider.get())}"

    @reactive.effect
    @reactive.event(input.add_plot_button)
    def _handle_add_plot_click():
        if current_n_plots.get() < MAX_PLOTS:
            current_n_plots.set(current_n_plots.get() + 1)
        if current_n_plots.get() == MAX_PLOTS:
            ui.update_action_button(
                "add_plot_button",
                session=session,
                label="Max plots reached",
                disabled=True,
            )

    @render.ui
    def plots():
        n_plots = current_n_plots.get()
        for i in range(1, n_plots + 1):
            slider_val = getattr(input, f"slider_{i}")()
            plot_server(f"plot_{i}", plot_id=i, mult=slider_val, max_plots=MAX_PLOTS)
        to_return = []
        for i in range(1, n_plots + 1):
            to_return.append(plot_ui(f"plot_{i}"))
            # to_return.append(plot_slider(f"slider_{i}"))
        return (to_return,)

    @reactive.effect
    @reactive.event(input.add_slider_button)
    def _():
        n = current_n_slider.get() + 1
        current_n_slider.set(n)
        ui.insert_ui(
            ui.input_slider(
                id=f"slider_{n}", min=1, max=n, step=1, value=n, label=f"Slider {n}"
            ),
            selector="#txt_out",
            where="afterEnd",
        )


app = App(app_ui, server)
